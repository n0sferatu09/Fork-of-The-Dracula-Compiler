# Отчёт по практике



## Выбранное ПО
The Dracula Compiler (пока что только лексер) - https://github.com/n0sferatu09/DraculaCompiler
Так как это мой проект, то найденные в нем баги я буду также исправлять, как и в форке, так и в оригинальном репозитории (там же лежит инструкция по эксплуатации.



## Найденные баги

### Баг №1

**Описание**: Малое кол-во символов для идентификаторов.

**Шаги воспроизведения**:
1. Вписать в компилируемый файл идентификатор длиной более 16 символов.
2. Скомпилировать файл по инструкции на оригинальном репозитории проекта.
3. Увидеть, что название идентификатора вывелось не полностью.

**Ожидаемое поведение**: Вывод в терминал полное название идентификатора.

**Фактическое поведение**: Вывод в терминал только первые 15 символов названия идентификатора.

**Серьёзность**: Высокая, так как в таблицу символов должно попадать полное название идентификатора, иначе парсер запутается.

**Скриншот/Видео**: Скриншот в папке screenshots/VeryFewCharacters.png, а так же screenshots/defines


### Баг №2

**Описание**: Переполнение массива из-за отсутствия проверки в цикле.

**Шаги воспроизведения**:
1. Вписать в компилируемый файл идентификатор длиной более 16 символов.
2. Скомпилировать файл по инструкции на оригинальном репозитории проекта.
3. Увидеть ошибку переполнения.

**Ожидаемое поведение**: Вывод в терминал полное название идентификатора.

**Фактическое поведение**: Ошибка из-за переполнения.

**Серьёзность**: Высокая, из-за переполнения падает прод.

**Скриншот/Видео**: Скриншот в папке screenshots/overflow.png


### Баг №3

**Описание**: Отстутствие проверки перед добавлением нулевого терминатора в конец строки. Из-за этого тоже может случится переполнение.

**Шаги воспроизведения**:
1. Вписать в компилируемый файл идентификатор длиной равной 16 символам или более.
2. Скомпилировать файл по инструкции на оригинальном репозитории проекта.
3. Увидеть ошибку переполнения из-за того, что в 17 ячейку массива(которой не существует) добавляется нулевой терминатор.

**Ожидаемое поведение**: Добавление нулевого терминатора в конец строки.

**Фактическое поведение**: Большая вероятность переполнения из-за отстутствия проверки.

**Серьёзность**: Высокая.

**Скриншот/Видео**: Скриншот в папке screenshots/OverflowWithTerminator.png или screenshots/Terminator.png


### Баг №4

**Описание**: Малое кол-во символов для чисел.

**Шаги воспроизведения**:
1. Вписать в компилируемый файл число длиной более 64 символов.
2. Скомпилировать файл по инструкции на оригинальном репозитории проекта.
3. В терминал выведутся только первые 63 символа.

**Ожидаемое поведение**: Вывод полного числа. 

**Фактическое поведение**: Вывод только первых 63 символов.

**Серьёзность**: Высокая, не правильная семантика программы и в последующем неправильная генерация кода.

**Скриншот/Видео**: Скриншот в папке screenshots/VeryFewDigits.png, а так же screenshots/defines


### Баг №5

**Описание**: Переполнение массива из-за отсутствия проверки в цикле.

**Шаги воспроизведения**:
1. Вписать в компилируемый файл число длиной более 64 символов.
2. Скомпилировать файл по инструкции на оригинальном репозитории проекта.
3. Увидеть ошибку переполнения.

**Ожидаемое поведение**: Вывод в терминал полного числа.

**Фактическое поведение**: Ошибка из-за переполнения.

**Серьёзность**: Высокая, утечка памяти.

**Скриншот/Видео**: Скриншот в папке screenshots/OverflowWithNumbers.png


### Баг №6

**Описание**: Отстутствие проверки перед добавлением нулевого терминатора в конец числа.

**Шаги воспроизведения**:
1. Вписать в компилируемый файл идентификатор длиной равной 64 символам или более.
2. Скомпилировать файл по инструкции на оригинальном репозитории проекта.
3. Увидеть ошибку переполнения из-за того, что в 65 ячейку массива(которой не существует) добавляется нулевой терминатор.

**Ожидаемое поведение**: Добавление нулевого терминатора в конец числа.

**Фактическое поведение**: Большая вероятность переполнения из-за отстутствия проверки.

**Серьёзность**: Высокая, утечка памяти.

**Скриншот/Видео**: Скриншот в папке screenshots/OverflowWithDigitTerminator.png или screenshots/Terminator.png


### Баг №7

**Описаниe**: Отсутствие отдельной проверки для однострочных('//') и многострочных('/*  */') комментариев.

**Шаги воспроизведения**:
1. Вписать в компилируемый файл однострочные или многострочные комментарии.
2. Скомпилировать файл по инструкции на оригинальном репозитории проекта.
3. Увидеть, что лексер в таком случае выведет в терминал "UKNOWN OPERATOR: /*".

**Ожидаемое поведение**: Вывод в терминал "FOUND A COMMENT: /* или */ или //".

**Фактическое поведение**: Выводит "UNKNOW OPERATOR".

**Серьёзность**: Высокая, будет ломаться синтаксис, семантика, да и сам компилятор вероятно загнется на стадии лексического анализа.


### Баг №8

**Описаниe**: Функция генерации пунктуаторов генерирует один большой неизвестный токен, если вдруг операторы находятся в строке. Из ("<<=") получается токен <<=");

**Шаги воспроизведения**:
1. Вписать в компилируемый файл подобную строку ("->");.
2. Скомпилировать файл по инструкции на оригинальном репозитории проекта.
3. Увидеть, что лексер выводит "UNKNOW OPERATOR".

**Ожидаемое поведение**: Вывод в терминал "FOUND A OPERATOR: ->".

**Фактическое поведение**: Выводит "UNKNOW OPERATOR".

**Серьёзность**: Высокая, компилятор будет сворачивать свою работу еще на стадии лексического анализа.




## Тесты

### Тест: Проверка на переполнение в случае генерации длинных идентификаторов.

**Описание теста**: Обработка переполнения.

**Шаги**:
1. Вписать в компилируемый файл длинный идентификатор.
2. Скомпилировать.
3. Выходит ли полное имя идентификатора в терминал?

**Результат до исправления**: Не прошёл: выводятся только первые 16 символов.

**Код до исправления** (если применимо):
```C
    int index = 0;
    char buffer[KEYWORD_SIZE + 1] = {0};

    buffer[index++] = first_letter;

    char current = fgetc(file);

    while(current != EOF && (isalnum(current) || current == '_')) {
        buffer[index++] = current;
        current = fgetc(file);
    }

    buffer[index] = '\0';

```
**Исправление** (если применимо): Добавил динамический массив. Теперь если index будет больше capacity, то capacity будет увеличиваться в двойне, благодаря этому, мы можем через функцию realloc делать массив больше в 2 раза. Так же это экономит память, если в случае с макросом KEYWORD_SIEZ мы выделяли память для 16 символов, то теперь из-за того, что стартуем с capacity = 3, условный if будет идеально вписываться в эти 3 символа, 2 на if и 1 на '\0'.

**Код после исправления** (если применимо):
```C
    int capacity = 3;
    int index = 0;
    char* buffer = malloc(sizeof(char) * capacity);

    if (buffer == NULL) {
        fprintf(stderr, "Memory allocation failed!\n");
        free(token);
        return NULL;
    }

    buffer[index++] = first_letter;

    char current = fgetc(file);

    while(current != EOF && (isalnum(current) || current == '_')) {
        if (index >= capacity) {
            capacity *= 2;
            char* new_buffer = realloc(buffer, sizeof(char) * capacity);

            if (new_buffer == NULL) {
                fprintf(stderr, "Memory reallocation failed!\n");
                free(buffer);
                free(token);
                return NULL;
            }

            buffer = new_buffer;
        }

        buffer[index++] = current;
        current = fgetc(file);
    }

    if (index >= capacity) {
        capacity++;
        char* new_buffer = realloc(buffer, sizeof(char) * capacity);

        if (new_buffer == NULL) {
            fprintf(stderr, "Memory reallocation failed!\n");
            free(buffer);
            free(token);
            return NULL;
        }

        buffer = new_buffer;
    }

    buffer[index] = '\0';

```

**Результат после исправления**: Прошёл, теперь можно вписывать идентификаторы любой длины, пока память не кончится)))


### Тест: [Название, напр. "Проверка ввода данных"]

**Описание теста**: [Что проверяем, напр. "Обработка положительных чисел"]

**Шаги**:
1. [Шаг 1, напр. "Запустить ПО"]
2. [Шаг 2, напр. "Ввести число и проверить вывод"]
3. [И т.д.]

**Результат до исправления**: [Прошёл/Не прошёл + описание, напр. "Не прошёл: неверный вывод"]

**Код до исправления** (если применимо):
```js
// Вставьте фрагмент кода с багом
```

**Исправление** (если применимо): [Опишите изменения]

**Код после исправления** (если применимо):
```js
// Вставьте исправленный код
```

**Результат после исправления**: [Прошёл/Не прошёл + описание]


## Процесс исправления
[Описание]

## Вклад участников
- Иванов И.И.: Тестирование.
